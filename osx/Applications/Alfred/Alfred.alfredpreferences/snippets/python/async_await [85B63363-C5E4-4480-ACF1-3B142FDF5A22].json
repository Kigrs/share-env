{
  "alfredsnippet" : {
    "snippet" : "import asyncio\nimport time\nimport functools\nimport logging\n\nimport requests\n\nfrom log_utils import Logger\nlogger = Logger(log_level=logging.DEBUG).logger\n\nPLACES = ['tokyo','kyoto','nagoya','osaka','hokkaido','fukuoka','okinawa']\nCONCURRENT_LIMIT = 2\nSEARCH_URL='https:\/\/www.google.com\/search?q={}'\n\nasync def search(loop, place):\n    logger.debug(f'{PLACES.index(place)+1} {place} searching..')\n    res_msg = await loop.run_in_executor(None, functools.partial(requests.get, SEARCH_URL.format(place)))\n    return f'{PLACES.index(place)+1} {place}:{res_msg}'\n\ndef limit_search(loop, places, concurrent_limit=CONCURRENT_LIMIT):\n    logger.info(f\"concurrent_limit:{concurrent_limit}\")\n    sem = asyncio.Semaphore(concurrent_limit)\n    async def call_search(loop, place):\n        async with sem:\n            return await search(loop, place)\n    return asyncio.gather(*[call_search(loop, place) for place in places])\n\ndef show_results(results):\n    for result in results:\n        logger.info(result)\n\ndef main():\n    loop = asyncio.get_event_loop()\n    \n    logger.info(\"[no limit search]\")\n    start = time.time()\n    tasks = [search(loop, place) for place in PLACES]\n    future = asyncio.gather(*tasks)\n    loop.run_until_complete(future)\n    results = future.result()\n    show_results(results)\n    end = time.time()\n    logger.info(f'Took {end-start} seconds\\n')\n\n    logger.info(\"[limit search]\")\n    start = time.time()\n    future = limit_search(loop, places=PLACES)\n    loop.run_until_complete(future)\n    results = future.result()\n    show_results(results)\n    end = time.time()\n    logger.info(f'Took {end-start} seconds\\n')\n\n    loop.close\n\n\nif __name__ == \"__main__\":\n    start = time.time()\n    main()\n    end = time.time()\n    logger.info(f'Total Took {end-start} seconds')\n\n",
    "dontautoexpand" : true,
    "uid" : "85B63363-C5E4-4480-ACF1-3B142FDF5A22",
    "name" : "async_await",
    "keyword" : "async_await"
  }
}